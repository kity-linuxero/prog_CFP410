<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Programación</title>
		<link rel="stylesheet" href="css/egg.css">
		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css">
		
		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">

	</head>
	<body>

		<div class="reveal">
			<div class="slides">

				<section  data-background="./static/back.jpg"  data-background-color="#dddddd" data-background-size="contain">
					
					<h2>Introducción a la programación</h2>
				</section>

				<section>
					<h2>Clase 9</h2>
					<h3>Contenido para hoy</h3>
					<ul>
						<li>Excepciones</li>
						<small>
							<ul>
								<li><a href="clase9.html#/excepciones">Qué son las excepciones</a></li>
								<li><a href="clase9.html#/handling">Manejo de excepciones</a></li>
								<li><a href="clase9.html#/en_python">Excepciones en Python</a></li>
								<li><a href="clase9.html#/built-in">built-in exceptions</a></li>
								<li><a href="clase9.html#/raise">Lanzar excepciones</a></li>
								<li><a href="clase9.html#/ejemplos">Ejemplos</a></li>
							</ul>
						</small>
						
						<li><a href="clase9.html#/ejercicio">Ejercicio en clase</a></li>
						<li><a href="clase9.html#/glosario">Glosario</a></li>
					</ul>
				</section>

				


				<section>
					<section id="poo">
						<h3>Introducción a la Programación Orientada a objetos</h3>
					</section>

					<section id="poo1">
						<h3>Programación orientada a objetos</h3>
						<p><small>La <strong>Programación orientada a Objetos</strong> (POO) es un <strong>paradigma</strong> de programación, es decir, un modelo o un estilo de programación que nos da unas guías sobre cómo trabajar con él. Se basa en el <strong>concepto de clases y objetos</strong>. </small></p>
						<p><small>Con el paradigma de Programación Orientado a Objetos lo que buscamos es dejar de centrarnos en la lógica pura de los programas, para empezar a pensar en objetos, lo que constituye la base de este paradigma. Esto nos ayuda a poder modelar objetos de la vida real o abstractos con su comportamiento y características de forma directa hacia un lenguaje de programación.</small></p>

					</section>

					<section id="poo2">
						<h3>Programación orientada a objetos<small></small></h3>
						<p><small>La Programación Orientada a objetos permite que el código sea reutilizable, organizado y fácil de mantener. Sigue el principio de desarrollo de software utilizado por muchos programadores <strong>DRY</strong>(Don't Repeat Yourself) «entre otros principios», para evitar duplicar el código y crear de esta manera programas eficientes. Además, evita el acceso no deseado a los datos o la exposición de código mediante la <strong>encapsulación</strong> y la <strong>abstracción</strong>, de la que hablaremos en detalle más adelante.</small></p>
						<p><small>Un programa orientado a objetos puede verse como: «Un conjunto de <strong>objetos</strong> que colaboran enviándose <strong>mensajes</strong>».</small></p>
					</section>

					<section id="poo3">
						<h3>Conceptos de POO</h3>
						<p><small>La POO introduce nuevos conceptos, que amplían los conceptos vistos hasta el momento.</small></p>
			
						<ul>
							<!-- <li><strong>Clase</strong><small>Es una especie de "plantilla" o "molde" que define de manera genérica los datos o <strong>atributos</strong> que va a poseer el objeto y el <strong>comportamiento</strong> (implementado en métodos) que tendrá el mismo. Una clase es un modelo que define un conjunto de variables y métodos apropiado para operar con dichos datos. Cada objeto creado a partir de la clase se denomina <em>instancia</em> de la clase. -->
							<li><strong>Clase</strong><small>Es una especie de "plantilla" o "molde" que define de manera genérica la estructura y comportamiento de los objetos.</li>
							<ul>
								<li><strong>Atributos:</strong> Almacenan el estado de la clase por medio de <em>variables</em> (variables de instancia o de clase), estructura de datos e incluso otras clases.</li>
								<li><strong>Métodos:</strong> Son funciones que describen lo que es capaz de hacer el objeto.</li>
							</ul>
							</small></li>
							<li><strong>Objeto</strong><small>Es una <strong>instancia</strong> de una clase. Es decir, un objeto creado a partir de la plantilla de una clase definida. Un objeto contiene <em>atributos</em> (datos) y un <em>comportamiento</em> provisto por los <em>métodos</em> (funciones) definidos en la clase de la cual es instancia.</small></li>
							<!-- <li><strong>Método</strong><small>Es la implementación en código de un <strong>mensaje</strong> que el objeto sabe responder. Definen el comportamiento del objeto y por lo tanto es lo que un objeto puede o es capaz de hacer. </small></li>
							<li><strong>Atributo o propiedad</strong><small>Es un dato que se define en la clase y que serán los datos que tendrá el objeto. El valor de los datos pueden cambiar durante la ejecución del programa.</small></li> -->
						</ul>
				
						
					</section>

					<section>					
						<h3>Conceptos de POO<small>(p2)</small></h3>
						<p><small>Por ejemplo, una clase para representar animales puede llamarse "animal" y tener una serie de <strong>atributos</strong>, como "nombre" y "edad", y una serie con los comportamientos que estos pueden tener, como caminar o comer, y que a su vez se implementan como <strong>métodos</strong> en la clase (funciones).</small></p>
						<p><small>Otro ejemplo, podemos tener una clase para representar vehículos, llamada "Vehiculo". Los <strong>atributos</strong> pueden ser patente, marca, modelo, etc. Y el <strong>comportamiento</strong> puede ser arrancar, poner alarma, acelerar, etc.</small></p>
						<p><small>Como puede verse, cosas <em>cotidianas</em> como vehículos, animales o cualquier cosa que nos imaginemos pueden ser representadas en un lenguaje de programación mediante el paradigma <em>POO</em>.</small></p>
					</section>

					<section>					
						<h3>Conceptos de POO<small>(p3)</small></h3>
						<p><small>Además de los conceptos previamente vistos, la POO se basa en 6 principios básicos:</small></p>
			
						<ul>
							<li>Herencia</li>
							<li>Cohesión</li>
							<li>Abstracción</li>
							<li>Polimorfismo</li>
							<li>Acoplamiento</li>
							<li>Encapsulamiento</li>
						</ul>
						<p><small>Estos principios se verán mas adelante.</small></p>
					</section>

					<section>
						<h3>Motivación</h3>
						<p><small>Luego de esta breve explicación, parece ser que la POO es bastante lógica, pero no es algo que existió siempre en los lenguajes de programación y muchos de estos no lo soportan. </small></p>
						<p><small>En parte surgió debido a las necesidades de los programadores, en el trascurso de los años, de hacer programas cada vez mas complejos. </small></p>
						<p><small>En el mundo de la programación hay gran cantidad de aplicaciones que realizan tareas muy similares y es importante identificar los <em>patrones</em> que nos permiten no reinventar la rueda. La programación orientada a objetos intentaba resolver esto.</small></p>
						<p><small>Uno de los primeros mecanismos que se han utilizado para agrupar bloques y resolver problemas repetitivos fueron las <strong>funciones</strong>. Si bien las funciones son muy útiles, no son suficientes para resolver problemas complejos por si solas.</small></p>
					</section>
					
					<section>
						<h3>Motivación <small>(p2)</small></h3>
						<p><small>Imaginemos que tenemos un juego de naves moviéndose por la pantalla. Cada una de ellas tendrá una una posición <code>(x,y)</code>, un color, un tamaño de nave como también un comportamiento cada una.</small></p>
						<p><small>Sin usar <em>POO</em> tendríamos que definir una variable por cada dato que queremos almacenar para cada nave. Si tenemos 10 naves y 5 datos para almacenar por cada nave, <em>¡Tendríamos que definir 50 variables!</em>. El código sería un verdadero desorden y ni hablar si quisieramos modificar la cantidad de naves o agregar atributos nuevos.</small></p>
						<p><small>Si diseñamos el programa con una arquitectura <em>orientada a objetos</em> esto sería muy sencillo con apenas unas cuantas líneas de código.</small></p>
						<p><small>Mediante una <strong>clase</strong> podríamos definir lo general de las naves; sus <strong>atributos</strong> y <strong>características</strong> y luego "fabricar" naves (crear <strong>objetos</strong>) cada una con sus cualidades.</small></p>
					</section>

					<section>
						<h2>¿Preguntas?</h2>
					</section>

				</section>

				<section id="definicion">
					<section>
						<h2>Definir clases, atributos y métodos</h2>
					</section>

					<section>
						<h3>Definiendo clases</h3>
						<p><small>Como hemos <a href="#/poo3">mencionado</a> anteriormente, una <strong>clase</strong> es como un "molde" para crear objetos. Imaginemos que queremos crear un objeto para representar un auto.</small></p>
					
						<pre data-id="code-animation"><code class="python" data-trim>
							# Creamos una clase vacía
							class Auto:
								pass # No hace nada
						</code></pre>

						<p><small>Ahora que tenemos la <strong>clase</strong>, podemos crear un <strong>objeto</strong> de la misma. Podemos hacerlo como si de una variable normal se tratase. Nombre de la variable igual a la clase con (). Dentro de los paréntesis irían los parámetros de entrada si los hubiera.</small></p>

						<pre data-id="code-animation"><code class="python" data-trim>
							mi_auto = Auto()
							otro_auto = Auto()
						</code></pre>
						
						<p><small>Cuando se crea un objeto a partir de una clase se dice que se <em>instancia</em> una clase o que un objeto es <em>instancia</em> de una determinada clase.</small></p>
						<p class="fragment"><small><strong>IMPORTANTE:</strong> Por <em>convención</em>, los nombres de las clases empiezan <em>siempre</em> en <strong>mayúsculas</strong>.</small></p>
					</section>

					<section>
						<h2>Definiendo atributos</h2>
						<p>Las clases pueden tener atributos y es importante saber que hay dos tipos:</p>

						<p>
							<ul>
								<li>Atributos de <strong>instancia</strong>:<small>También llamados atributo de objeto. Pertenecen solo a la instancia en particular. Es decir cada objeto tendrá sus propios datos basados en sus atributos de instancia. Para acceder al atributo de instancia, será requisito <em>instanciar</em> una clase.</small></li>
								<li>Atributos de <strong>clase</strong>:<small>Son atributos que pertenecen a la clase y que todos los objetos tendrán ese atributo. Como es un atributo de la clase, no es necesario instanciar una clase para acceder al atributo. Sino que basta con invocar a la clase seguido por el atributo.</small></li>
							</ul>
						</p>
						<!-- <p class="fragment"><small>Para resumir, podemos decir que los atributos que tendrá un objeto se definen con <strong>variables</strong> y su comportamiento serán definidos por <strong>funciones</strong>.</small></p> -->
						<p><small>De ahora en mas diremos <em>variables de instancia</em> a los atributos de instancia y <em>variables de clase</em> a los atributos de clase.</small></p>
					</section>

					<!-- <section>
						<h2>Definiendo atributos <small>(p2)</small></h2>
						<p>Vamos a definir una clase con sus atributos.</p>

						<pre data-id="code-animation"><code class="python" data-trim>
							class Auto:
								marca = "VW"
								color = None

							mi_auto = Auto() # Instanciamos la clase auto
							mi_auto.color = 'Rojo'
							
							otro_auto = Auto()
							otro_auto.color = 'Blanco'

							print(mi_auto.marca) # VW
							print(mi_auto.color) # Rojo
							print(otro_auto.color) # Blanco
						</code></pre>
						<p><small>Hemos creado una clase <code>Auto</code> con dos atributos de <em>instancia</em>; marca y color. Marca tiene un valor por defecto. Son tratados como <em>variables</em> normales, pero se acceden a ella anteponiendo el nombre del <em>objeto</em>. Quedando finalmente: <code>objeto.atributo</code></small></p>
					</section> -->

					<section>
						<h3>Definiendo métodos: constructor</h3>
						<!-- <h4>Constructor</h4> -->
						<p><small>Los lenguajes nos proveen un <em>constructor</em> por defecto para que cada clase pueda construir objetos. Pero a veces resulta muy útil tener nuestros propios <em>constructores</em>.</small></p>
						<p><small>En <code>Python</code> hay un <em>método</em> especial llamado <code>__init__</code> que se usa como constructor.</small></p>
						
						<pre data-id="code-animation"><code class="python" data-trim data-line-numbers>
							class Auto:
								def __init__(self, marca, color): # Constructor
									self.marca= marca # Variable de instancia
									self.color= color # Variable de instancia

							mi_auto = Auto('Ford', 'Blanco') # Se instancia un objeto
							print(mi_auto.marca, mi_auto.color) # Ford Blanco
						</code></pre>

						<p class="fragment"><small>Seguramente te hayas fijado en el <code>self</code> que se pasa como parámetro de entrada del método. Es una variable que representa la instancia de la clase, y deberá estar siempre ahí.</small></p>
						<p class="fragment"><small>El uso de <code>__init__</code> y el doble __ no es una coincidencia. Cuando veas un método con esa forma, significa que está <em>reservado</em> para un uso especial del lenguaje.</small></p>
						

					</section>

					<section>
						<h2>Definiendo métodos</h2>
						
						<pre data-id="code-animation"><code class="python" data-trim>
							class Auto:
								origen = "Argentina" # Variable de clase
								
								def __init__(self, un_modelo): # Constructor
									self.modelo= un_modelo	# Variable de instancia
							
								def arrancar(self):
									print("Auto encendido")
								def acelerar(self, velocidad):
									print(f"Acelerando a {velocidad}km/h")
								
							mi_auto = Auto('Cruze')
							mi_auto.arrancar()
							mi_auto.acelerar(40)
						</code></pre>
						<p><small>Podemos acceder a los <em>métodos</em> con un punto luego del identificador del objeto. El primer parámetro de los métodos <em>debe ser</em> <code>self</code>. <a href="https://www.mycompiler.io/view/JdPnZIvjeYB" target="_blank">Ver código</a></small></p>
						<p class="fragment"><small>En Python las variables de clase se definen fuera de los métodos y las variables de instancia van dentro de algún método.</small></p>
					</section>

					<section>
						<h2>Ejemplos</h2>
						
						<p><small>Queremos modelar los semáforos de una ciudad para que permita pasar o no a los autos en cada esquina de una larga avenida.</small></p>
						<p><small>El semáforo debe tener un estado de luz para saber en qué luz está (Rojo o Verde) y algún mecanismo que permita intercambiar entre un color de luz y el otro.</small></p>
						<p class="fragment"><small>¿Cómo se les ocurre que podemos hacer?</small></p>
						<p class="fragment"><small><a href="https://www.mycompiler.io/view/Lcly15uBOFt" target="_blank">Vamos al ejemplo resuelto</a></small></p>

						<p class="fragment"><small>Los métodos pueden invocar a las variables de instancia, de clase o incluso otros métodos del objeto o de la clase. <a href="https://www.mycompiler.io/view/AfLZLONyIeD" target="_blank">Veamoslo en un ejemplo:</a></small></p>
						
					</section>


				</section>

				<section>


					<section id="ejercicio">
						<h3>Ejercicio en clase</h3>
						<p><small> Escriba un módulo llamado <code>calcu_cfp.py</code> que contenga las funciones <code>suma(a,b)</code>, <code>resta(a,b)</code>, <code>producto(a,b)</code>, <code>divide(a,b)</code>.
							Cada función debe recibir dos parámetros para realizar las operaciones descritas y debe retornar el valor. Si llega a haber algún error, debe informarlo con la excepción correspondiente.</small></p>
						
						<p><small>Escriba un programa llamado <code>ej_clase9.py</code> que importe el módulo <code>calcu_cfp</code> y le pida al usuario dos valores y una operación para realizar entre ellos.</small></p>
						<p><small>El programa debe ser robusto para no interrumpirse inesperadamente por un error y debe informar que "algo malo ha ocurrido" pero sin finalizar, dando la oportunidad al usuario de corregir los datos que haya ingresado mal.</small></p>
	
						<p><small>Intercambie el módulo con el o la compañera que está a su lado para comprobar que su módulo funciona en tu programa.</small></p>
	
					</section>

				</section>

				

		
					<section id="glosario">
						<h3>Glosario</h3>
						<ul>
							<li><strong>Excepción:</strong><small> Condición inesperada o inusual, que surge durante la ejecución del programa y no puede ser manejada en el contexto local.</small></li>
							<li><strong>Manejo de excepciones:</strong><small> Los lenguajes que soportan manejo de excepciones, proveen alguna forma que podamos controlar el comportamiento del programa cuando se produce una excepción.</small></li>
							<li><strong>Manejador:</strong><small> Se refiere al bloque de código encargado para tratar una excepción. El bloque de código está entre <code>try except</code> </small></li>
							<li><strong>Modelo de terminación:</strong><small> Es una de las técnicas que usa un lenguaje para actuar frente a una excepción. El modelo de terminación indica que el programa termina el bloque de ejecución donde se produjo la excepción para ir directamente al manejador y luego NO sigue por la siguiente línea de código se quedó, sino que la ejecución sigue luego del bloque que produjo la excepción. </small></li>						
						</ul>

					</section>



				
				





				<section data-transition="zoom" data-background="./static/back.jpg"  data-background-color="#dddddd" data-background-size="contain">
					<h3>¡Fin de la clase!</h3>
					<a href="./clase8.html"> < Ir a clase anterior</a><br>
					<!-- <a href="https://github.com/kity-linuxero/prog_CFP410/blob/main/practicas/practica7.md"> < Ir a la práctica 7</a><br> -->
					

				</section>
					<section data-transition="zoom" data-background="./static/back.jpg"  data-background-color="#dddddd" data-background-size="contain">
						<h2>Bibliografia</h2>
						<small>
						
						<p><a href="https://docs.python.org/3/">Python oficial documentation</a> </p>
						<p><a href="https://ellibrodepython.com" target="_blank">El libro de Python</a></p>
						<p><a href="https://raw.githubusercontent.com/espinoza/ThinkPython2-spanish/master/book/thinkpython2-spanish.pdf">ThinkPython 2nd edition<br><small>(Downey-Elkner-Meyers)</small></a></p>
						<p><a href="https://pynative.com/python-exceptions">PyNative</a></p>
						<!-- <h3>Referencias</h3> -->
						<h3>Recursos</h3>
						<p><a href="https://www.online-python.com/" target="_blank">Interprete Python Online</a></p>
						<p><a href="https://www.mycompiler.io/new/python" target="_blank">My Compiler IDE Online</a></p>
					</small>
					</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/zoom/zoom.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealZoom ]
			});
		</script>
	</body>
</html>
